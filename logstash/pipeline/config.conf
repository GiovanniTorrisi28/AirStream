input {
  # Sorgente 1
  http_poller {
    urls => {
      openweather_weather => {
        method => get
        url => "https://api.openweathermap.org/data/2.5/weather?lat=${LAT}&lon=${LON}&appid=${API_KEY}&units=metric&lang=it"
        headers => { Accept => "application/json" }
      }
    }
    request_timeout => 30
    schedule => { every => "1m" }
    codec => "json"
    tags => ["meteo"]
  }

   # Sorgente 2
   http_poller {
    urls => {
      altra_sorgente => {
        method => get
        url => "http://api.openweathermap.org/data/2.5/air_pollution?lat=${LAT}&lon=${LON}&appid=${API_KEY}"
      }
    }
    request_timeout => 30
    schedule => { every => "1m" }
    codec => "json"
    tags => ["aria"]
  }

}
  
filter {
  if "meteo" in [tags] {
    mutate {
      add_field => {
        "temperature" => "%{[main][temp]}"
        "humidity"    => "%{[main][humidity]}"
        "wind_speed"  => "%{[wind][speed]}"
        "measurement_time" => "%{[dt]}"
        "city"        => "%{[name]}"
      }
    }
    mutate {
      convert => {
        "temperature" => "float"
        "humidity"    => "integer"
        "wind_speed"  => "float"
        "measurement_time" => "integer"
      }
    }
    date {
      match => ["measurement_time", "UNIX"]
      target => "measurement_time"
      timezone => "UTC"
    }
    mutate {
      remove_field => ["main","wind","weather","coord","sys","base","cod","clouds","visibility","id","timezone","@version","event","dt", "name"]
    }
  }

  if "aria" in [tags] {
    split {
      field => "list"
    }

    mutate {
      add_field => {
        "aqi"   => "%{[list][main][aqi]}"
        "co"    => "%{[list][components][co]}"
        "no"    => "%{[list][components][no]}"
        "no2"   => "%{[list][components][no2]}"
        "o3"    => "%{[list][components][o3]}"
        "so2"   => "%{[list][components][so2]}"
        "pm2_5" => "%{[list][components][pm2_5]}"
        "pm10"  => "%{[list][components][pm10]}"
        "nh3"   => "%{[list][components][nh3]}"
        "dt"    => "%{[list][dt]}"
        "lat"   => "%{[coord][lat]}"
        "lon"   => "%{[coord][lon]}"
      }
      remove_field => ["event", "list", "@version", "coord"]
    }

    mutate {
      convert => {
        "co" => "float"
        "no" => "float"
        "no2" => "float"
        "o3" => "float"
        "so2" => "float"
        "pm2_5" => "float"
        "pm10" => "float"
        "nh3" => "float"
        "dt" => "integer"
        "lat" => "float"
        "lon" => "float"
        "aqi" => "integer"
      }
    }

    # trasformazione dt in measurement_time leggibile
    date {
      match => [ "dt", "UNIX" ]
      target => "measurement_time"
      timezone => "UTC"
    }

    mutate {
      remove_field => ["dt"]
    }

    # creazione del campo location formato dalla coppia di coordinate
    mutate {
      add_field => {
        "city" => "${CITY}"
        "location" => "%{lat},%{lon}"
      }
    }
  }

}

output {

  stdout { codec => rubydebug }
  
  # Scrittura su kafka nel topic della sorgente 1
  if "meteo" in [tags] {
    kafka {
      bootstrap_servers => "kafka:9092"
      topic_id => "weatherdata"
      codec => json
    }
  }

  # Scrittura su kafka nel topic della sorgente 2
  if "aria" in [tags] {
    kafka {
      bootstrap_servers => "kafka:9092"
      topic_id => "airquality"
      codec => json
    }
  }
}
